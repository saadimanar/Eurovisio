#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <stdbool.h>
#include <string.h>
#include "map.h"
#include "list.h"
#include "eurovision.h"

#define JUDGE_SCORE 10

typedef struct eurovision_t {
    Map states;
    Map judges;
} *Eurovision;

typedef struct state_t {
    char *stateName;
    char *songName;
    Map votes;
} *State;

typedef struct judge_t {
    char *judgeName;
    int score[JUDGE_SCORE];
} *Judge;

MapKeyElement copyInt(MapKeyElement n) {
    if (!n) {
        return NULL;
    }
    int *copy = malloc(sizeof(*copy));
    if (!copy) {
        return NULL;
    }
    *copy = *(int *) n;
    return copy;
}
void freeInt(MapKeyElement n) {
    free(n);
}
int compareInts(MapKeyElement n1, MapKeyElement n2) {
    return (*(int *) n1 - *(int *) n2);
}

void freeState(MapDataElement state) {
    State state1 = (State)state;
    free(state1->stateName);
    free(state1->songName);
    mapDestroy(state1->votes);
    free(state);
}
void freeJudge(MapDataElement judge) {
    Judge judge1 = (Judge) judge;
    free(judge1->judgeName);
    free(judge1->score);
    free(judge1);
}
MapDataElement copyState(MapDataElement state){
    if(state == NULL){
        return NULL;
    }
    State newState = malloc(sizeof(*newState));
    if(newState == NULL){
        return NULL;
    }
    newState->stateName = malloc((sizeof(char))*(strlen(((State)state)->stateName)+1));
    if(newState->stateName == NULL){
        freeState(newState);
        return NULL;
    }
    strcpy_s((newState->stateName), (strlen(((State)state)->stateName)+1), (((State)state)->stateName));
    newState->songName = malloc((sizeof(char))*(strlen(((State)state)->songName)+1));
    if(newState->songName == NULL){
        freeState(newState);
        return NULL;
    }
    strcpy_s((newState->songName), (strlen(((State)state)->songName)+1), (((State)state)->songName));
    newState->votes = mapCopy(((State)state)->votes);
    if(newState->votes == NULL){
        freeState(newState);
        return NULL;
    }
    return newState;
}
MapDataElement copyJudge(MapDataElement judge){
    if(judge == NULL){
        return NULL;
    }
    Judge newJudge = (Judge) malloc(sizeof(Judge*));
    if(newJudge == NULL){
        return NULL;
    }
    newJudge->judgeName = malloc((sizeof(char))*(strlen(((Judge)judge)->judgeName)+1));
    if(newJudge->judgeName == NULL){
        freeJudge(newJudge);
        return NULL;
    }
    strcpy_s((newJudge->judgeName), (strlen(((Judge)judge)->judgeName)+1), ((Judge)judge)->judgeName);
    for(int i=0; i<JUDGE_SCORE; i++){
        newJudge->score[i] = ((Judge)judge)->score[i];
    }
    return newJudge;
}

void removeJudgeVote(Judge judge, int stateId){
    int* ptr = judge->score;
    int i = 0;
    while((ptr[i] != stateId) && (i < JUDGE_SCORE)){
        ptr++;
        i++;
    }
    if(i<JUDGE_SCORE) {
        while (i < JUDGE_SCORE - 1) {
            ptr[i] = ptr[i + 1];
            i++;
        }
        ptr[i] = 0;
    }
}
bool validJudgeName(const char* judgeName){
    int i = 0;
    while(judgeName[i]){
        if((judgeName[i] != ' ') || (judgeName[i] < 'a') || (judgeName[i] > 'z'))
            return false;
    }
    return true;
}

Eurovision eurovisionCreate(){
    Eurovision eurovision = malloc(sizeof(*eurovision));
    if(eurovision == NULL){
        return NULL;
    }
    eurovision->states = mapCreate(copyState, copyInt, freeState, freeInt, compareInts);
    if(eurovision->states == NULL){
        eurovisionDestroy(eurovision);
        return NULL;
    }
    eurovision->judges = mapCreate(copyInt, copyJudge, freeInt, freeJudge, compareInts);
    if(eurovision->judges == NULL){
        eurovisionDestroy(eurovision);
        return NULL;
    }
    return eurovision;
}

void eurovisionDestroy(Eurovision eurovision){
    mapDestroy(eurovision->states);
    mapDestroy(eurovision->judges);
    free(eurovision);
}

EurovisionResult eurovisionAddState(Eurovision eurovision, int stateId,
                                    const char *stateName,
                                    const char *songName){
    if((eurovision == NULL) || (stateName == NULL) || (songName == NULL)){
        return EUROVISION_NULL_ARGUMENT;
    }
    if(stateId < 0){
        return EUROVISION_INVALID_ID;
    }
    if(mapContains(eurovision->states, &stateId)){
        return EUROVISION_STATE_ALREADY_EXIST;
    }
    State newState = malloc(sizeof(*newState));
    if(newState == NULL){
        return EUROVISION_OUT_OF_MEMORY;
    }
    newState->songName = malloc((sizeof(char)*(strlen(songName)))+1);
    if(newState->songName == NULL){
        freeState(newState);
        return EUROVISION_OUT_OF_MEMORY;
    }
    newState->stateName = malloc((sizeof(char)*(strlen(stateName)))+1);
    if(newState->songName == NULL){
        freeState(newState);
        return EUROVISION_OUT_OF_MEMORY;
    }
    newState->votes = mapCreate(copyInt, copyInt, freeInt, freeInt, compareInts);
    if(newState->votes == NULL){
        freeState(newState);
        return EUROVISION_OUT_OF_MEMORY;
    }
    if(mapPut(eurovision->states, &stateId, newState) == MAP_SUCCESS){
        return EUROVISION_SUCCESS;
    }
    return EUROVISION_OUT_OF_MEMORY;
}

EurovisionResult eurovisionRemoveState(Eurovision eurovision, int stateId){
    if(eurovision == NULL){
        return EUROVISION_NULL_ARGUMENT;
    }
    if(stateId < 0){
        return EUROVISION_INVALID_ID;
    }
    if(mapRemove(eurovision->states, &stateId) != MAP_SUCCESS){
        return EUROVISION_STATE_NOT_EXIST;
    }
    int* ptrJudge = mapGetFirst(eurovision->judges);
    while(ptrJudge != NULL){
        Judge iterator = mapGet(eurovision->judges, ptrJudge);
        for (int i = 1; i <= JUDGE_SCORE; ++i) {
            removeJudgeVote(iterator, stateId);
        }
        ptrJudge = mapGetNext(eurovision->judges);
    }
    return EUROVISION_SUCCESS;
}

EurovisionResult eurovisionAddJudge(Eurovision eurovision, int judgeId,
                                    const char *judgeName,
                                    int *judgeResults){
    if((eurovision == NULL) || (judgeName == NULL) || (judgeResults == NULL)){
        return EUROVISION_NULL_ARGUMENT;
    }
    if(!validJudgeName(judgeName)){
        return EUROVISION_INVALID_NAME;
    }
    if(judgeId < 0){
        return EUROVISION_INVALID_ID;
    }
    if(mapContains(eurovision->judges, &judgeId)){
        return EUROVISION_JUDGE_ALREADY_EXIST;
    }
    Judge newJudge = (Judge) malloc(sizeof(Judge*));
    if(newJudge == NULL){
        return EUROVISION_OUT_OF_MEMORY;
    }
    newJudge->judgeName = malloc((sizeof(char)*(strlen(judgeName))) + 1);
    if(newJudge->judgeName == NULL){
        freeJudge(newJudge);
        return EUROVISION_OUT_OF_MEMORY;
    }
    int *ptr = judgeResults;
    for (int i = 0; i < JUDGE_SCORE; ++i) {
        if(!mapContains(eurovision->states, judgeResults)){
            freeJudge(newJudge);
            return EUROVISION_STATE_NOT_EXIST;
        }
        ptr[i] = judgeResults[i];
        judgeResults++;
    }
    if(mapPut(eurovision->judges, &judgeId, newJudge) == EUROVISION_SUCCESS){
        return EUROVISION_SUCCESS;
    }
    return EUROVISION_OUT_OF_MEMORY;
}

EurovisionResult eurovisionRemoveJudge(Eurovision eurovision, int judgeId){
    if(eurovision == NULL){
        return EUROVISION_NULL_ARGUMENT;
    }
    if(judgeId < 0){
        return EUROVISION_INVALID_ID;
    }
    if(mapRemove(eurovision->judges, &judgeId) != MAP_SUCCESS) {
        return EUROVISION_JUDGE_NOT_EXIST;
    }
    return EUROVISION_SUCCESS;
}

EurovisionResult eurovisionAddVote(Eurovision eurovision, int stateGiver, int stateTaker){
    if(eurovision == NULL){
        return EUROVISION_NULL_ARGUMENT;
    }
    if((stateGiver < 0) || (stateTaker < 0)){
        return EUROVISION_INVALID_ID;
    }
    if((!mapContains(eurovision->states, &stateGiver)) || (!mapContains(eurovision->states, &stateTaker))){
        return EUROVISION_STATE_NOT_EXIST;
    }
    if (stateGiver == stateTaker){
        return EUROVISION_SAME_STATE;
    }
    State ptr = mapGet(eurovision->states, &stateGiver);
    int* stateVotes = mapGet(ptr->votes, &stateTaker);
    if(stateVotes != NULL) {
        *stateVotes = (*stateVotes) + 1;
    } else{
        int start = 1;
        if(mapPut(ptr->votes, &stateTaker, &start) != MAP_SUCCESS){
            return EUROVISION_OUT_OF_MEMORY;
        }
    }
    return EUROVISION_SUCCESS;
}

EurovisionResult eurovisionRemoveVote(Eurovision eurovision, int stateGiver,
                                      int stateTaker){
    if(eurovision == NULL){
        return EUROVISION_NULL_ARGUMENT;
    }
    if((stateGiver < 0) || (stateTaker < 0)){
        return EUROVISION_INVALID_ID;
    }
    if((!mapContains(eurovision->states, &stateGiver)) || (!mapContains(eurovision->states, &stateTaker))){
        return EUROVISION_STATE_NOT_EXIST;
    }
    if (stateGiver == stateTaker){
        return EUROVISION_SAME_STATE;
    }
    State ptr = mapGet(eurovision->states, &stateGiver);
    int* stateVotes = mapGet(ptr->votes, &stateTaker);
    if(stateVotes != NULL) {
        *stateVotes = (*stateVotes) - 1;
    }
    return EUROVISION_SUCCESS;
}
