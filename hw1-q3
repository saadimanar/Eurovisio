#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <stdbool.h>
#include <string.h>
#include "map.h"
#include "list.h"
#include "eurovision.h"

#define JUDGE_SCORE 10

typedef struct eurovision_t {
    Map states;
    Map judges;
} *Eurovision;

typedef struct state_t {
    char *stateName;
    char *songName;
    Map votes;
} *State;

typedef struct judge_t {
    char *judgeName;
    int score[JUDGE_SCORE];
} *Judge;

MapKeyElement copyInt(MapKeyElement n) {
    if (!n) {
        return NULL;
    }
    int *copy = malloc(sizeof(*copy));
    if (!copy) {
        return NULL;
    }
    *copy = *(int *) n;
    return copy;
}
MapKeyElement copyChar(ListElement n) {
    if (!n) {
        return NULL;
    }
    char *copy = malloc(sizeof(*copy));
    if (!copy) {
        return NULL;
    }
    *copy = *(char *) n;
    return copy;
}
void freeInt(MapKeyElement n) {
    free(n);
}
void freeChar(ListElement n) {
    free(n);
}
int compareInts(MapKeyElement n1, MapKeyElement n2) {
    return (*(int *) n1 - *(int *) n2);
}
MapKeyElement copyDouble(MapKeyElement n) {
    if (!n) {
        return NULL;
    }
    double *copy = malloc(sizeof(*copy));
    if (!copy) {
        return NULL;
    }
    *copy = *(double *) n;
    return copy;
}
void freeDouble(MapDataElement n) {
    free(n);
}
int compareChars(ListElement listElement1, ListElement listElement2){
    return (*(char*)listElement1 - *(char*)listElement2);
}

void freeState(MapDataElement state) {
    State state1 = (State)state;
    free(state1->stateName);
    free(state1->songName);
    mapDestroy(state1->votes);
    free(state);
}
void freeJudge(MapDataElement judge) {
    Judge judge1 = (Judge) judge;
    free(judge1->judgeName);
    free(judge1->score);
    free(judge1);
}
MapDataElement copyState(MapDataElement state){
    if(state == NULL){
        return NULL;
    }
    State newState = malloc(sizeof(*newState));
    if(newState == NULL){
        return NULL;
    }
    newState->stateName = malloc((sizeof(char))*(strlen(((State)state)->stateName)+1));
    if(newState->stateName == NULL){
        freeState(newState);
        return NULL;
    }
    strcpy_s((newState->stateName), (strlen(((State)state)->stateName)+1), (((State)state)->stateName));
    newState->songName = malloc((sizeof(char))*(strlen(((State)state)->songName)+1));
    if(newState->songName == NULL){
        freeState(newState);
        return NULL;
    }
    strcpy_s((newState->songName), (strlen(((State)state)->songName)+1), (((State)state)->songName));
    newState->votes = mapCopy(((State)state)->votes);
    if(newState->votes == NULL){
        freeState(newState);
        return NULL;
    }
    return newState;
}
MapDataElement copyJudge(MapDataElement judge){
    if(judge==NULL){
        return NULL;
    }
    Judge newJudge = (Judge) malloc(sizeof(Judge*));
    if(newJudge == NULL){
        return NULL;
    }
    newJudge->judgeName = malloc((sizeof(char))*(strlen(((Judge)judge)->judgeName)+1));
    if(newJudge->judgeName == NULL){
        freeJudge(newJudge);
        return NULL;
    }
    strcpy_s((newJudge->judgeName), (strlen(((Judge)judge)->judgeName)+1), ((Judge)judge)->judgeName);
    for(int i=0; i<JUDGE_SCORE; i++){
        newJudge->score[i] = ((Judge)judge)->score[i];
    }
    return newJudge;
}

void removeJudgeVote(Judge judge, int stateId){
    int* ptr = judge->score;
    int i = 0;
    while((ptr[i] != stateId) && (i < JUDGE_SCORE)){
        ptr++;
        i++;
    }
    if(i<JUDGE_SCORE) {
        while (i < JUDGE_SCORE - 1) {
            ptr[i] = ptr[i + 1];
            i++;
        }
        ptr[i] = 0;
    }
}
bool isValidJudgeName(const char* judgeName){
    int i=0;
    while(judgeName[i]){
        if (judgeName[i]== ' '){
            continue;
        }
        else{
            if ((judgeName[i] < 'a')||(judgeName[i] > 'z')){
                return false;
            }
        }
        i++;
    }
    return true;
}
int* maxScoreInt(Map map){
    int* max = (int*) (-1);
    int* id = (int*) (-1);
    MAP_FOREACH(int*, iterator, map){
        *id = *iterator;
        int* helper = mapGet(map, iterator);
        if(*helper == *max){
            if(*id > *iterator){
                *id = *iterator;
            }
        }
        if(*helper > *max){
            *max = *helper;
            *id = *iterator;
        }
    }
    return id;
}
int* audienceVotes(Map map){
    assert(map != NULL);
    int* audienceVotes = malloc(sizeof(audienceVotes)*JUDGE_SCORE);
    Map mapCopied = mapCopy(map);
    int i = 0;
    int* iterator = mapGetFirst(mapCopied);
    while((i < JUDGE_SCORE) && (iterator != NULL)){
        int *id = maxScoreInt(mapCopied);
        if(*id == -1){
            while (i < JUDGE_SCORE){
                audienceVotes[i] = 0;
                i++;
            }
            return audienceVotes;
        }
        mapRemove(mapCopied, id);
        audienceVotes[i] = *id;
        i++;
        iterator = mapGetFirst(mapCopied);
    }
    return audienceVotes;
}
int votesToScores(int votes){
    switch (votes){
        case 0:
            return 12;
        case 1:
            return  10;
        case 2:
            return  8;
        default:
            return -((votes-9)-1);
    }
}
int* maxScoreDouble(Map map){
    double* max = (double*) (-1);
    int* id = (int*) (-1);
    MAP_FOREACH(int*, iterator, map){
        *id = *iterator;
        double* helper = mapGet(map, iterator);
        if(*helper == *max){
            if(*id > *iterator){
                *id = *iterator;
            }
        }
        if(*helper > *max){
            *max = *helper;
            *id = *iterator;
        }
    }
    return id;
}
char* writeStateByOrder(char* state1, char* state2){
    char* result = malloc(sizeof(char)*((strlen(state1))+ strlen(state2) + 2));
    if(state1[0] > state2[0]){
        strcpy_s(result, (strlen(state1)+1), (state1));
        result[strlen(state1)+1] = '-';
        strcat_s(result, (strlen(state1))+ strlen(state2) + 2, state2);
    } else{
        strcpy_s(result, (strlen(state1)+1), (state1));
        result[strlen(state2)+1] = '-';
        strcat_s(result, (strlen(state1))+ strlen(state2) + 2, state2);
    }
    return result;
}

Eurovision eurovisionCreate(){
    Eurovision eurovision = malloc(sizeof(*eurovision));
    if(eurovision == NULL){
        return NULL;
    }
    eurovision->states = mapCreate(copyState, copyInt, freeState, freeInt, compareInts);
    if(eurovision->states == NULL){
        eurovisionDestroy(eurovision);
        return NULL;
    }
    eurovision->judges = mapCreate(copyJudge,copyInt, freeInt, freeJudge, compareInts);
    if(eurovision->judges == NULL){
        eurovisionDestroy(eurovision);
        return NULL;
    }
    return eurovision;
}

void eurovisionDestroy(Eurovision eurovision){
    mapDestroy(eurovision->states);
    mapDestroy(eurovision->judges);
    free(eurovision);
}

EurovisionResult eurovisionAddState(Eurovision eurovision, int stateId,
                                    const char *stateName,
                                    const char *songName){
    if((eurovision == NULL) || (stateName == NULL) || (songName == NULL)){
        return EUROVISION_NULL_ARGUMENT;
    }
    if(stateId < 0){
        return EUROVISION_INVALID_ID;
    }
    if(mapContains(eurovision->states, &stateId)){
        return EUROVISION_STATE_ALREADY_EXIST;
    }
    State newState = malloc(sizeof(*newState));
    if(newState == NULL){
        return EUROVISION_OUT_OF_MEMORY;
    }
    newState->songName = malloc((sizeof(char)*(strlen(songName)))+1);
    if(newState->songName == NULL){
        freeState(newState);
        return EUROVISION_OUT_OF_MEMORY;
    }
    newState->stateName = malloc((sizeof(char)*(strlen(stateName)))+1);
    if(newState->songName == NULL){
        freeState(newState);
        return EUROVISION_OUT_OF_MEMORY;
    }
    newState->votes = mapCreate(copyInt, copyInt, freeInt, freeInt, compareInts);
    if(newState->votes == NULL){
        freeState(newState);
        return EUROVISION_OUT_OF_MEMORY;
    }
    if(mapPut(eurovision->states, &stateId, newState) == MAP_SUCCESS){
        return EUROVISION_SUCCESS;
    }
    return EUROVISION_OUT_OF_MEMORY;
}

EurovisionResult eurovisionRemoveState(Eurovision eurovision, int stateId){
    if(eurovision == NULL){
        return EUROVISION_NULL_ARGUMENT;
    }
    if(stateId < 0){
        return EUROVISION_INVALID_ID;
    }
    if(mapRemove(eurovision->states, &stateId) != MAP_SUCCESS){
        return EUROVISION_STATE_NOT_EXIST;
    }
    int* ptrJudge = mapGetFirst(eurovision->judges);
    while(ptrJudge != NULL){
        Judge iterator = mapGet(eurovision->judges, ptrJudge);
        for (int i = 1; i <= JUDGE_SCORE; ++i) {
            removeJudgeVote(iterator, stateId);
        }
        ptrJudge = mapGetNext(eurovision->judges);
    }
    return EUROVISION_SUCCESS;
}

EurovisionResult eurovisionAddJudge(Eurovision eurovision, int judgeId,
                                    const char *judgeName,
                                    int *judgeResults){
    if((eurovision==NULL)||(judgeName==NULL)||(judgeResults==NULL)){
        return EUROVISION_NULL_ARGUMENT;
    }
    if(judgeId<0){
        return EUROVISION_INVALID_ID;
    }
    for (int i=0;i<10;i++) {
        if(judgeResults[i]<0){
            return EUROVISION_INVALID_ID;
        }
    }

    if(!isValidJudgeName(judgeName)){
        return EUROVISION_INVALID_NAME;
    }
    if(mapContains(eurovision->judges, &judgeId)){
        return EUROVISION_JUDGE_ALREADY_EXIST;
    }
    Judge newJudge = (Judge) malloc(sizeof(Judge*));
    if(newJudge==NULL){
        return EUROVISION_OUT_OF_MEMORY;
    }
    newJudge->judgeName = malloc((sizeof(char)*(strlen(judgeName)))+1);
    if(newJudge->judgeName==NULL){
        freeJudge(newJudge);
        return EUROVISION_OUT_OF_MEMORY;
    }
    int *ptr = judgeResults;
    for (int i=0; i<JUDGE_SCORE;++i) {
        if(!mapContains(eurovision->states, judgeResults)){
            freeJudge(newJudge);
            return EUROVISION_STATE_NOT_EXIST;
        }
        ptr[i] = judgeResults[i];
        judgeResults++;
    }
    if(mapPut(eurovision->judges,&judgeId,newJudge)!=MAP_SUCCESS){
        return EUROVISION_OUT_OF_MEMORY;
    }
    return EUROVISION_SUCCESS;
}

EurovisionResult eurovisionRemoveJudge(Eurovision eurovision, int judgeId){
    if(eurovision == NULL){
        return EUROVISION_NULL_ARGUMENT;
    }
    if(judgeId < 0){
        return EUROVISION_INVALID_ID;
    }
    if(mapRemove(eurovision->judges, &judgeId) != MAP_SUCCESS) {
        return EUROVISION_JUDGE_NOT_EXIST;
    }
    return EUROVISION_SUCCESS;
}

EurovisionResult eurovisionAddVote(Eurovision eurovision, int stateGiver, int stateTaker){
    if(eurovision == NULL){
        return EUROVISION_NULL_ARGUMENT;
    }
    if((stateGiver < 0) || (stateTaker < 0)){
        return EUROVISION_INVALID_ID;
    }
    if((!mapContains(eurovision->states, &stateGiver)) || (!mapContains(eurovision->states, &stateTaker))){
        return EUROVISION_STATE_NOT_EXIST;
    }
    if (stateGiver == stateTaker){
        return EUROVISION_SAME_STATE;
    }
    State ptr = mapGet(eurovision->states, &stateGiver);
    int* stateVotes = mapGet(ptr->votes, &stateTaker);
    if(stateVotes != NULL) {
        *stateVotes = (*stateVotes) + 1;
    } else{
        int start = 1;
        if(mapPut(ptr->votes, &stateTaker, &start) != MAP_SUCCESS){
            return EUROVISION_OUT_OF_MEMORY;
        }
    }
    return EUROVISION_SUCCESS;
}

EurovisionResult eurovisionRemoveVote(Eurovision eurovision, int stateGiver,
                                      int stateTaker){
    if(eurovision == NULL){
        return EUROVISION_NULL_ARGUMENT;
    }
    if((stateGiver < 0) || (stateTaker < 0)){
        return EUROVISION_INVALID_ID;
    }
    if((!mapContains(eurovision->states, &stateGiver)) || (!mapContains(eurovision->states, &stateTaker))){
        return EUROVISION_STATE_NOT_EXIST;
    }
    if (stateGiver == stateTaker){
        return EUROVISION_SAME_STATE;
    }
    State ptr = mapGet(eurovision->states, &stateGiver);
    int* stateVotes = mapGet(ptr->votes, &stateTaker);
    if(stateVotes != NULL) {
        *stateVotes = (*stateVotes) - 1;
    }
    return EUROVISION_SUCCESS;
}

List eurovisionRunContest(Eurovision eurovision, int audiencePercent){
    if((audiencePercent >= 1) && (audiencePercent <= 100)){
        return NULL;
    }
    if(eurovision == NULL) {
        return NULL;
    }
    Map states = mapCreate(copyInt, copyInt, freeInt, freeInt, compareInts);
    if(states == NULL){
        return NULL;
    }
    Map judges = mapCreate(copyInt, copyInt, freeInt, freeInt, compareInts);
    if(judges == NULL){
        return NULL;
    }
    Map allScore = mapCreate(copyDouble, copyInt, freeDouble, freeInt, compareInts);
    if(allScore == NULL){
        mapDestroy(states);
        mapDestroy(judges);
        return NULL;
    }
    MAP_FOREACH(int*, iterator, eurovision->states){
        if(mapPut(states, iterator, (int*)0) != MAP_SUCCESS) {
            mapDestroy(states);
            mapDestroy(judges);
            mapDestroy(allScore);
            return NULL;
        }
        if(mapPut(judges, iterator, (int*)0) != MAP_SUCCESS) {
            mapDestroy(states);
            mapDestroy(judges);
            mapDestroy(allScore);
            return NULL;
        }
        if(mapPut(allScore, iterator, (double*)0) != MAP_SUCCESS) {
            mapDestroy(states);
            mapDestroy(judges);
            mapDestroy(allScore);
            return NULL;
        }
    }
    MAP_FOREACH(int*, iterator, eurovision->states){
        State state = mapGet(eurovision->states, iterator);
        int* audience_votes = audienceVotes(state->votes);
        for (int i = 0; i < JUDGE_SCORE; ++i) {
            int* id = (int*) (-1);
            *id = audience_votes[i];
            int* score = mapGet(state->votes, id);
            *score = *score + votesToScores(i);
        }
    }
    MAP_FOREACH(int*, iterator, eurovision->judges){
        Judge judge = mapGet(eurovision->judges, iterator);
        for (int i = 0; i < JUDGE_SCORE; ++i) {
            int* score = mapGet(judges, (int*)(judge->score)[i]);
            *score = *score + votesToScores(i);
        }
    }
    MAP_FOREACH(int*, iterator, eurovision->states){
        int* stateScore = mapGet(states, iterator);
        int* judgeScore = mapGet(judges, iterator);
        double all = (((double)(*stateScore)/12)*(1-((double)audiencePercent/100)))+(((double)(*judgeScore)/12)*((double)audiencePercent/100));
        if(mapPut(allScore, iterator, &all) != MAP_SUCCESS){
            mapDestroy(states);
            mapDestroy(judges);
            mapDestroy(allScore);
            return NULL;
        }
    }

    int size = mapGetSize(eurovision->states);
    List result = listCreate(copyInt, freeInt);
    if(result == NULL){
        mapDestroy(states);
        mapDestroy(judges);
        mapDestroy(allScore);
        return NULL;
    }
    for (int j = 0; j < size; ++j) {
        int* max = maxScoreDouble(allScore);
        if(listInsertLast(result, max) != LIST_SUCCESS){
            mapDestroy(states);
            mapDestroy(judges);
            mapDestroy(allScore);
            listDestroy(result);
            return NULL;
        }
        mapRemove(allScore, max);
    }
    return result;
}

List eurovisionRunAudienceFavorite(Eurovision eurovision){
    return eurovisionRunContest(eurovision, 100);
}

List eurovisionRunGetFriendlyStates(Eurovision eurovision){
    if(eurovision == NULL){
        return NULL;
    }
    Map topStates = mapCreate(copyInt, copyInt, freeInt, freeInt, compareInts);
    if(topStates == NULL){
        return NULL;
    }
    MAP_FOREACH(int*, iterator, eurovision->states){
        State state = mapGet(eurovision->states, iterator);
        int* audience_votes = audienceVotes(state->votes);
        if(mapPut(topStates, iterator, (int*)audience_votes[0]) != MAP_SUCCESS){
            mapDestroy(topStates);
            return NULL;
        }
    }
    List result = listCreate(copyChar, freeChar);
    if(result == NULL){
        mapDestroy(topStates);
        return NULL;
    }
    int* ptr = mapGetFirst(topStates);
    while(ptr != NULL){
        int* firstState = mapGet(topStates, ptr);
        int* secondState = mapGet(topStates, firstState);
        if(*firstState == *secondState){
            State state1 = mapGet(eurovision->states, firstState);
            State state2 = mapGet(eurovision->states, secondState);
            char* stateName1 = state1->stateName;
            char* stateName2 = state2->stateName;
            if(listInsertLast(result, writeStateByOrder(stateName1, stateName2)) != LIST_SUCCESS){
                mapDestroy(topStates);
                listDestroy(result);
                return NULL;
            }
        }
        mapRemove(topStates, firstState);
        mapRemove(topStates, secondState);
        ptr = mapGetFirst(topStates);
    }
    if(listSort(result, compareChars) != LIST_SUCCESS){
        mapDestroy(topStates);
        listDestroy(result);
        return NULL;
    }
    return result;
}
